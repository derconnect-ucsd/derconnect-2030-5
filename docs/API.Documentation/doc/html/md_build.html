<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EPRI 2030.5 Client: Build System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EPRI 2030.5 Client
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_build.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Build System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><code>build.sh</code> is a Bash based build system/script, the purpose of the script is to simplify C based cross platfom developement using gcc. While the script shares features of a build system it is not intended as a replacement for existing build systems such as <code>make</code> and the 'auto'-tools (<code>automake</code>/<code>autoconf</code>) whose scope and application are much broader. The scope here is limited to simply compiling applications and libraries that are part this framework using gcc as the compiler and Bash as the shell/scripting environment.</p>
<p>Bash was chosen as the language because of it's widespread use as a scripting language and shell environment and it's use in configuring software (including its use in build systems). The features of the Bash language (arrays, introspection of variables) make it well suited to describe build targets, and the flexibility of using a scripting language makes it possible to extend the build system, for example defining custom build commands. These features are more than adequate in addressing the current needs of the framework and future needs as the framework is ported to other systems.</p>
<h2>Targets </h2>
<p>Running the build script with no arguments will attempt to build the targets specified in <code>targets.sh</code>. Within <code>targets.sh</code> the variable <code>targets</code> should be defined, this variable is an array of targets to be built: </p><pre class="fragment">targets=( ... )
</pre><p>Each target can be either:</p>
<ul>
<li>A subdirectory with its own <code>targets.sh</code></li>
<li>A target with it's own build command</li>
<li>A C based target (executable, object, or shared library)</li>
<li>A sublist of targets that contains any of these possibilities</li>
</ul>
<p>Targets can also be specified on the command line, in this case the file <code>targets.sh</code> is still read and processed but the command line arguments become the list of targets.</p>
<h2>Subdirectory Target </h2>
<p>The subdirectory target is a subdirectory off of the main project directory with its own <code>targets.sh</code>. Building a subdirectory target is equivalant to changing to that directory and executing the build script. This feature is used to define subprojects, these can be worked on independently of the main project.</p>
<h2>Build Command Target </h2>
<p>The build command target is a target that is "built" by executing a Bash function. The name of this function is the target name with name <code>_build</code> appended to it. For example, if a function is defined within <code>targets.sh</code> as: </p><pre class="fragment">hello_build () { echo "Hello World"; }
</pre><p>Then this target can be built by executing the command: </p><pre class="fragment">./build.sh hello
</pre><h2>C Based Targets </h2>
<p>C based targets can be either an executable, object, or shared library. For a given target name <code>target</code>, the following variables can be defined:</p>
<ul>
<li><code>target_flags</code> - compiler flags used to compile the target</li>
<li><code>target_libs</code> - libraries to be linked with the target</li>
<li><code>target_objects</code> - objects to be linked with the target</li>
</ul>
<p>The type of the target is determined by its name, targets ending in <code>.o</code> are compiled objects, targets of the form <code>lib{target}.so</code> are shared library targets, targets without either extensions are executable targets. In all cases, the <code>_flags</code>, <code>_libs</code>, and <code>_objects</code> variables will have the target name without the extensions, so that in compiling <code>libtest.so</code>, the variables <code>test_flags</code>, <code>test_libs</code> and <code>test_objects</code> will be used.</p>
<p>Only a single source file is used as the input to compile a target, its name is the same as the target name with the ".c" extension used instead of the target extensions. So, to produce <code>target</code>, <code>target.o</code>, or <code>libtarget.so</code> (an executable, object, or shared library) the file <code>target.c</code> is used as the input file.</p>
<h2>Sublist Targets </h2>
<p>The final type of targets are sublist targets, these are Bash arrays that can contain any of the prior types of targets. To create a sublist target, simply create a Bash array and include it in the list of targets: </p><pre class="fragment">sublist=( ... )
targets=( ... sublist ... )
</pre><p>The <code>_flags,</code>_libs<code>, and</code>_objects` variables can be defined for a sublist target: </p><pre class="fragment">sublist_flags=( ... )
sublist_libs=( ... )
sublist_objects=( ... )
</pre><p>When this occurs the targets included in the sublist will inherit these attributes. This provides a useful way to group together executables or other targets that share common attributes such as the compiler flags used and libraries linked.</p>
<h2>Build Types </h2>
<p>The following build types can be specified on the command line:</p>
<ul>
<li><code>debug</code> - Compile targets with debugging symbols included and no optimization.</li>
<li><code>static</code> - Use static linking.</li>
<li><code>cross</code> - Use the cross compiler instead of the default compiler.</li>
</ul>
<p>With no arguments specified, the default build type is optimized code generation. Any of these build types can be combined, for example running the command: </p><pre class="fragment">./build.sh debug cross
</pre><p>Will use the cross compiler and compile the targets for debugging.</p>
<h2>Dependencies and Rebuilding </h2>
<p>Changes to the source files are frequently made in the course of development, and as it so happens, the compiled targets (executables, objects, and shared libraries) become out of date or unsyncronized with the source files. In such cases a rebuild is required and it is desirable to rebuild only those files that require it. In order to do that, we need to know what files a target depends on. If any of these files are newer than the target then a rebuild is required.</p>
<p>In compiling a C source file, there are two kinds of dependencies, source file dependencies created by including other source files (<code>#include</code> directives), and binary dependencies that are implied through linking. The latter dependencies are explicit within the build system, specified by listing the linked objects required to build a target, the former can be discovered by the gcc compiler itself using the <code>-MM</code> option. Before compiling a source file, the build system checks a dependency file, one generated by running gcc with the <code>-MM</code> option. From that listing of files, the build system can decide whether to rebuild a target or not.</p>
<p>The source dependency listings are only created the first time a target is compiled. Because source files can sometimes change their source dependencies (by adding or removing <code>#include</code> directives), the dependency files themselves sometimes need to regenerated, this can be done with the "dep" command: </p><pre class="fragment">./build.sh dep
</pre><p>Finally, a change in build type will require the targets to be rebuilt, for this purpose the build system stores the set of build arguments and compares this list with the build arguments specified on the command line. A change in arguments will force a rebuild for all the targets. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
